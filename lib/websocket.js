// Generated by CoffeeScript 2.6.1
(function() {
  //###
  // Copyright (C) 2012, Bill Burdick
  // License: ZLIB license
  //###
  var CometConnection, Connection, ProxyMux, SocketConnection, WebSocketConnection, _, addDirHandler, addXusCometHandler, badPage, comet, contentType, createHandler, dirMap, exports, extensions, fs, nextHandler, path, send, url, urlHandlers, ws;

  exports = module.exports = require('./base');

  ({ProxyMux, SocketConnection, WebSocketConnection, Connection, CometConnection} = require('./transport'));

  ws = require('ws');

  _ = require('./lodash.min');

  path = require('path');

  fs = require('fs');

  send = require('send');

  url = require('url');

  comet = require('comet.io');

  exports.startWebSocketServer = function(config, ready) {
    var app;
    app = require('http').createServer(createHandler(config));
    if (config.port) {
      app.listen(config.port, config.host, ready);
    } else {
      app.listen(ready);
    }
    return app;
  };

  exports.addXusCometHandler = addXusCometHandler = function(xusServer, pattern) {
    var cometServer, handler;
    cometServer = comet.createServer();
    handler = function(pathname, req, res, next) {
      return cometServer.serve(req, res);
    };
    handler.urlPat = pattern;
    urlHandlers.splice(0, 0, handler);
    return cometServer.on('connection', function(socket) {
      return new CometConnection(xusServer, socket);
    });
  };

  exports.dirMap = dirMap = [];

  urlHandlers = [];

  extensions = {
    js: 'application/javascript',
    html: 'text/html',
    gif: 'image/gif',
    css: 'text/css',
    png: 'image/png'
  };

  exports.addDirHandler = addDirHandler = function(urlPat, dir) {
    var dirPattern, handler;
    if (dir[dir.length - 1] !== '/') {
      dir = `${dir}/`;
    }
    dirPattern = new RegExp(`^${dir}`);
    handler = function(pathname, req, res, next) {
      var file;
      file = path.resolve(pathname.replace(urlPat, dir));
      if (`${file}/` === dir) {
        file = `${file}/index.html`;
        pathname = `${pathname}/index.html`;
      }
      if (file.match(dirPattern)) {
        return send(req, pathname.replace(urlPat, "/")).root(dir).pipe(res);
      } else {
        return next();
      }
    };
    handler.urlPat = urlPat;
    return urlHandlers.push(handler);
  };

  createHandler = function(config) {
    return function(req, res) {
      //req.on 'end', ->
      return nextHandler(0, url.parse(req.url).pathname, req, res);
    };
  };

  nextHandler = function(index, pathname, req, res) {
    var handler;
    handler = urlHandlers[index];
    if (!handler) {
      return badPage(req, res);
    } else if (handler && pathname.match(handler.urlPat)) {
      return handler(pathname, req, res, function() {
        return nextHandler(index + 1, pathname, req, res);
      });
    } else {
      return nextHandler(index + 1, pathname, req, res);
    }
  };

  contentType = function(file) {
    var ref;
    return (ref = extensions[file.replace(/^.*\.([^.]*)$/, '$1')]) != null ? ref : 'text/plain';
  };

  badPage = function(req, res) {
    res.writeHead(404);
    return res.end(`<html><body>Web page ${req.url} not available</body></html>`);
  };

  exports.connectXus = function(xusServer, httpServer) {
    var wServer;
    xusServer.webSocketServer = httpServer;
    wServer = new ws.Server({
      noServer: true
    });
    return httpServer.on('upgrade', function(req, socket, head) {
      if (req.url === '/cmd') {
        return new SocketConnection(xusServer, socket, head);
      } else if (req.url === '/peer') {
        return wServer.handleUpgrade(req, socket, head, function(con) {
          var wsCon;
          wsCon = new WebSocketConnection(xusServer, con);
          return wsCon.sendPending();
        });
      } else {
        return con.destroy();
      }
    });
  };

  exports.connectProxy = function(config, httpServer, connectBlock) {
    var proxy, wServer;
    exports.proxy = proxy = new ProxyMux({
      processBatch: function(con, demuxedBatch) {
        proxy.verbose(`proxy sending: ${JSON.stringify(demuxedBatch)} to ${con.constructor.name}`);
        return con.send(demuxedBatch);
      }
    });
    proxy.verbose = config.verbose;
    wServer = new ws.Server({
      noServer: true
    });
    httpServer.on('upgrade', function(req, socket, head) {
      proxy.verbose(`REQUEST: ${req.url}`);
      if (req.url === '/cmd') { // proxy this new connection from a peer
        return proxy.newConnectionEndpoint(function(proxyCon) {
          return new SocketConnection(proxyCon, socket, head);
        });
      } else if (req.url === '/proxy') { // main connection from a Xus server
        return wServer.handleUpgrade(req, socket, head, function(con) {
          var wsCon;
          wsCon = new WebSocketConnection(proxy, con);
          wsCon.sendPending();
          return connectBlock(proxy);
        });
      } else {
        return con.destroy();
      }
    });
    return proxy;
  };

}).call(this);

//# sourceMappingURL=websocket.js.map
