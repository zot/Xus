// Generated by CoffeeScript 1.3.3
(function() {
  var Connection, ProxyMux, SocketConnection, WebSocketConnection, addDirHandler, addXusCometHandler, badPage, comet, contentType, createHandler, dirMap, exports, extensions, fs, nextHandler, path, send, url, urlHandlers, ws, _, _ref;

  exports = module.exports = require('./base');

  _ref = require('./transport'), ProxyMux = _ref.ProxyMux, SocketConnection = _ref.SocketConnection, WebSocketConnection = _ref.WebSocketConnection, Connection = _ref.Connection;

  ws = require('ws');

  _ = require('./lodash.min');

  path = require('path');

  fs = require('fs');

  send = require('send');

  url = require('url');

  comet = require('comet.io');

  exports.startWebSocketServer = function(config, ready) {
    var app;
    app = require('http').createServer(createHandler(config));
    if (config.port) {
      app.listen(config.port, config.host, ready);
    } else {
      app.listen(ready);
    }
    return app;
  };

  exports.addXusCometHandler = addXusCometHandler = function(xusServer, pattern) {
    var cometServer, handler;
    cometServer = comet.createServer();
    handler = function(pathname, req, res, next) {
      return cometServer.serve(req, res);
    };
    handler.urlPat = pattern;
    urlHandlers.splice(0, 0, handler);
    return cometServer.on('connection', function(socket) {
      return new CometConnection(xusServer, socket);
    });
  };

  exports.dirMap = dirMap = [];

  urlHandlers = [];

  extensions = {
    js: 'application/javascript',
    html: 'text/html',
    gif: 'image/gif',
    css: 'text/css',
    png: 'image/png'
  };

  exports.addDirHandler = addDirHandler = function(urlPat, dir) {
    var dirPattern, handler;
    if (dir[dir.length - 1] !== '/') {
      dir = "" + dir + "/";
    }
    dirPattern = new RegExp("^" + dir);
    handler = function(pathname, req, res, next) {
      var file;
      file = path.resolve(pathname.replace(urlPat, dir));
      if (("" + file + "/") === dir) {
        file = "" + file + "/index.html";
        pathname = "" + pathname + "/index.html";
      }
      if (file.match(dirPattern)) {
        return send(req, pathname.replace(urlPat, "/")).root(dir).pipe(res);
      } else {
        return next();
      }
    };
    handler.urlPat = urlPat;
    return urlHandlers.push(handler);
  };

  createHandler = function(config) {
    return function(req, res) {
      return req.on('end', function() {
        return nextHandler(0, url.parse(req.url).pathname, req, res);
      });
    };
  };

  nextHandler = function(index, pathname, req, res) {
    var handler;
    handler = urlHandlers[index];
    if (!handler) {
      return badPage(req, res);
    } else if (handler && pathname.match(handler.urlPat)) {
      return handler(pathname, req, res, function() {
        return nextHandler(index + 1, pathname, req, res);
      });
    } else {
      return nextHandler(index + 1, pathname, req, res);
    }
  };

  contentType = function(file) {
    var _ref1;
    return (_ref1 = extensions[file.replace(/^.*\.([^.]*)$/, '$1')]) != null ? _ref1 : 'text/plain';
  };

  badPage = function(req, res) {
    res.writeHead(404);
    return res.end("<html><body>Web page " + req.url + " not available</body></html>");
  };

  exports.connectXus = function(xusServer, httpServer) {
    var wServer;
    xusServer.webSocketServer = httpServer;
    wServer = new ws.Server({
      noServer: true
    });
    return httpServer.on('upgrade', function(req, socket, head) {
      if (req.url === '/cmd') {
        return new SocketConnection(xusServer, socket, head);
      } else if (req.url === '/peer') {
        return wServer.handleUpgrade(req, socket, head, function(con) {
          return new WebSocketConnection(xusServer, con);
        });
      } else {
        return con.destroy();
      }
    });
  };

  exports.connectProxy = function(config, httpServer, connectBlock) {
    var proxy, wServer;
    exports.proxy = proxy = new ProxyMux({
      processBatch: function(con, demuxedBatch) {
        proxy.verbose("proxy sending: " + (JSON.stringify(demuxedBatch)) + " to " + con.constructor.name);
        return con.send(demuxedBatch);
      }
    });
    proxy.verbose = config.verbose;
    wServer = new ws.Server({
      noServer: true
    });
    httpServer.on('upgrade', function(req, socket, head) {
      proxy.verbose("REQUEST: " + req.url);
      if (req.url === '/cmd') {
        return proxy.newConnectionEndpoint(function(proxyCon) {
          return new SocketConnection(proxyCon, socket, head);
        });
      } else if (req.url === '/proxy') {
        return wServer.handleUpgrade(req, socket, head, function(con) {
          new WebSocketConnection(proxy, con);
          return connectBlock(proxy);
        });
      } else {
        return con.destroy();
      }
    });
    return proxy;
  };

}).call(this);
