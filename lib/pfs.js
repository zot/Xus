// Generated by CoffeeScript 2.6.1
(function() {
  //###
  // Copyright (C) 2012, Bill Burdick
  // License: ZLIB license
  //###
  var basicFlock, ex, fs, q, readSome, writeSome;

  q = require('q');

  fs = require('fs-ext');

  ex = module.exports;

  ex.flock = function(fd, flags) {
    if (typeof fd === 'number') {
      return basicFlock(fd, flags);
    } else {
      return fd.then(function(realFd) {
        return basicFlock(realFd, flags);
      });
    }
  };

  ex.open = function(path, flags, mode) {
    return q.ninvoke(fs, 'open', path, flags, mode);
  };

  ex.close = function(fd) {
    return q.ninvoke(fs, 'close', fd);
  };

  ex.truncate = function(fd, len) {
    return q.ninvoke(fs, 'truncate', fd, len);
  };

  ex.mkdir = function(path, mode) {
    return q.ninvoke(fs, 'mkdir', path, mode);
  };

  ex.stat = function(path) {
    return q.ninvoke(fs, 'stat', path);
  };

  ex.fstat = function(fd) {
    return q.ninvoke(fs, 'stat', fd);
  };

  ex.createReadStream = function(path, options) {
    return q.ninvoke(fs, 'createReadStream', path, options);
  };

  ex.readFile = function(fd) {
    var done;
    done = q.defer();
    readSome(done, fd, new Buffer(4096), '');
    return done.promise;
  };

  ex.writeFile = function(fd, str) {
    var done;
    done = q.defer();
    writeSome(done, fd, new Buffer(str), 0);
    return done.promise;
  };

  ex.readStream = function(path) {
    var done, str;
    done = q.defer();
    str = fs.createReadStream(path);
    str.on('open', function(fd) {
      return done.resolve([str, fd]);
    });
    str.on('error', function(e) {
      return done.reject(e);
    });
    return done.promise;
  };

  ex.pipe = function(stream1, stream2) {
    var done;
    done = q.defer();
    stream1.on('end', function() {
      return done.resolve(stream1);
    });
    stream1.on('error', function(e) {
      return done.reject(e);
    });
    stream1.pipe(stream2);
    return done.promise;
  };

  basicFlock = function(fd, flags) {
    return q.ninvoke(fs, 'flock', fd, flags);
  };

  readSome = function(d, fd, buf, str) {
    var err;
    try {
      return fs.read(fd, buf, 0, buf.length, null, function(err, bytesRead, buffer) {
        if (err) {
          return d.reject(err);
        } else if (bytesRead === 0) {
          return d.resolve(str);
        } else {
          return readSome(d, fd, buf, str + buffer.toString(null, 0, bytesRead));
        }
      });
    } catch (error) {
      err = error;
      return d.reject(err);
    }
  };

  writeSome = function(d, fd, buf, bufPos) {
    var err;
    try {
      return fs.write(fd, buf, bufPos, buf.length - bufPos, null, function(err, written, buf) {
        if (err) {
          return d.reject(err);
        } else if (written === 0) {
          return d.resolve(true);
        } else {
          return writeSome(d, fd, buf, bufPos + written);
        }
      });
    } catch (error) {
      err = error;
      return d.reject(err);
    }
  };

}).call(this);

//# sourceMappingURL=pfs.js.map
