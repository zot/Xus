// Generated by CoffeeScript 2.6.1
(function() {
  //###
  // Copyright (C) 2012, Bill Burdick
  // License: ZLIB license
  //###
  var DelegationHandler, DirectConnection, Peer, VarStorage, _, connectedPeerMethods, d, exports, prefixes, setCmds,
    indexOf = [].indexOf;

  ({d} = exports = module.exports = require('./base'));

  ({setCmds, prefixes, VarStorage} = require('./proto'));

  _ = require('./lodash.min');

  exports.Peer = Peer = class Peer {
    constructor(con) {
      var defaultHandler, peer;
      this.setConnection(con);
      this.inTransaction = false;
      this.changeListeners = {};
      this.treeListeners = {};
      this.valueListeners = {};
      this.queuedListeners = [];
      this.name = null; // this is set on connect, by the original @processBatch
      this.namePrefixPat = /^$/;
      this.varStorage = new VarStorage(this);
      peer = this;
      defaultHandler = this.varStorage.handlerFor;
      this.varStorage.handlerFor = function(key) {
        return defaultHandler.call(this, key.replace(peer.namePrefixPat, 'this/'));
      };
      this.pendingBlocks = [];
    }

    addConnection(con) {}

    afterConnect(block) {
      if (this.name) {
        return block();
      } else {
        return this.pendingBlocks.push(block);
      }
    }

    setConnection(con1) {
      var ref, ref1;
      this.con = con1;
      if ((ref = this.con) != null) {
        ref.setMaster(this);
      }
      this.verbose = ((ref1 = this.con) != null ? ref1.verbose : void 0) || (function() {});
      return this.verbose(`ADDED CONNECTION: ${this.con}, verbose: ${this.verbose.toString()}`);
    }

    verbose() {}

    // API UTILS
    transaction(block) {
      this.inTransaction = true;
      block();
      this.inTransaction = false;
      return this.con.send();
    }

    send(batch) {
      return this.processBatch(this.con, batch);
    }

    get(key) {
      return this.varStorage.values[key];
    }

    listen(...args) {
      // IMPORTANT!
      // This is the initial @listen -- after connect, switches to connectedPeerMethods.listen
      return this.queuedListeners.push(args);
    }

    name(n) {
      return this.addCmd(['name', n]);
    }

    value(key, cookie, isTree, callback) {
      this.grabTree(key, callback);
      return this.addCmd(['value', key, cookie, isTree]);
    }

    set(key, value, storage) {
      return this.addCmd((storage ? ['set', key, value, storage] : ['set', key, value]));
    }

    put(key, index, value) {
      return this.addCmd(['put', key, value, index]);
    }

    splice(key, ...spliceArgs) {
      return this.addCmd(['splice', key, ...spliceArgs]);
    }

    removeFirst(key, value) {
      return this.addCmd(['removeFirst', key, value]);
    }

    removeAll(key, value) {
      return this.addCmd(['removeAll', key, value]);
    }

    removeTree(key, value) {
      return this.addCmd(['removeTree', key]);
    }

    manage(key, handler) {}

    // INTERNAL API
    processBatch(con, batch) {
      var block, cmd, j, k, l, len, len1, ref, ref1, results, v;
      // IMPORTANT!
      // This is the initial @processBatch -- after connect, switches to connectedPeerMethods.processBatch
      if (batch[0][0] === 'set' && batch[0][1] === 'this/name') {
        this.name = batch[0][2];
        this.date = batch[0][3];
        for (k in connectedPeerMethods) {
          v = connectedPeerMethods[k];
          this[k] = v;
        }
        ref = this.queuedListeners;
        for (j = 0, len = ref.length; j < len; j++) {
          cmd = ref[j];
          this.listen(...cmd);
        }
        this.queuedListeners = null;
        // processBatch was redefined, above
        this.processBatch(con, batch.slice(1));
        ref1 = this.pendingBlocks;
        results = [];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          block = ref1[l];
          results.push(block());
        }
        return results;
      }
    }

    // PRIVATE
    rename(newName) {
      var c, k, listen, newPath, oldName, oldPat, ref, ref1, ref2, t, thisPat, v;
      if (this.name !== newName) {
        newPath = `peer/${newName}`;
        thisPat = new RegExp("^this(?=/|$)");
        oldName = (ref = this.name) != null ? ref : 'this';
        this.name = newName;
        this.varStorage.sortKeys();
        exports.renameVars(this.varStorage.keys, this.varStorage.values, this.varStorage.handlers, oldName, newName);
        t = {};
        ref1 = this.treeListeners;
        for (k in ref1) {
          v = ref1[k];
          t[k.replace(thisPat, newPath)] = v;
        }
        this.treeListeners = t;
        c = {};
        ref2 = this.changeListeners;
        for (k in ref2) {
          v = ref2[k];
          c[k.replace(thisPat, newPath)] = v;
        }
        this.changeListeners = c;
        listen = `peer/${newName}/listen`;
        if (this.varStorage.values[listen]) {
          oldPat = new RegExp(`^peer/${oldName}(?=/|$)`);
          return this.varStorage.values[listen] = (k.replace(oldPat, newPath)).replace(thisPat, newPath);
        }
      }
    }

    sendTreeSets(sets, callback) {
      var j, k, len, msg, results, v, x;
      results = [];
      for (j = 0, len = sets.length; j < len; j++) {
        msg = sets[j];
        [x, k, v] = msg;
        results.push(callback(k, v, null, msg, sets));
      }
      return results;
    }

    tree(key, simulate, callback) {
      var idx, msg, msgs, prefix, ref;
      prefix = `^${key}(/|$)`;
      idx = _.sortedIndex(this.varStorage.keys, key);
      if (simulate) {
        msgs = [];
        while ((ref = this.varStorage.keys[idx]) != null ? ref.match(prefix) : void 0) {
          msgs.push(['set', this.varStorage.keys[idx], this.varStorage.values[this.varStorage.keys[idx]]]);
        }
        return this.sendTreeSets(msgs, callback);
      } else {
        msg = ['value', key, null, true];
        while (this.varStorage.keys[idx].match(prefix)) {
          msg.push(this.varStorage.keys[idx], this.varStorage.values[this.varStorage.keys[idx]]);
        }
        return callback(null, null, null, msg, [msg]);
      }
    }

    setsForTree(msg) {
      var i, j, ref, results;
      results = [];
      for (i = j = 4, ref = msg.length - 2; j <= ref; i = j += 2) {
        results.push(['set', msg[i], msg[i + 1]]);
      }
      return results;
    }

    grabTree(key, callback) {
      if (!this.treeListeners[key]) {
        this.treeListeners[key] = [];
      }
      return this.treeListeners[key].push(callback);
    }

    addCmd(cmd) {
      this.con.addCmd(cmd);
      if (!this.inTransaction) {
        return this.con.send();
      }
    }

    disconnect() {
      return this.con.close();
    }

    listenersFor(key) {
      return _.flatten(_.map(prefixes(key), (k) => {
        return this.changeListeners[k] || [];
      }));
    }

    handleDelegation(name, num, cmd) {
      // Override this for your own custom behavior
      return this.varStorage.handle(cmd, ((type, msg) => {
        return this.sendCmd(['error', type, msg]);
      }), () => {
        return this.sendCmd(['response', num, cmd]);
      });
    }

    sendCmd(cmd) {
      this.con.addCmd(cmd);
      return this.con.send();
    }

    //addHandler: (path, obj)-> @varStorage.addHandler @personalize(path), obj
    addHandler(path, obj) {
      return this.varStorage.addHandler(path, obj);
    }

    personalize(path) {
      return path.replace(new RegExp('^this(?=\/|$)'), `peer/${this.name}`);
    }

  };

  connectedPeerMethods = {
    processBatch: function(con, batch) {
      var block, cb, cmd, dcmd, index, j, key, l, len, len1, len2, len3, m, name, num, numKeys, o, ref, ref1, value, x;
      this.verbose(`PEER BATCH: ${JSON.stringify(batch)}`);
      numKeys = this.varStorage.keys.length;
      for (j = 0, len = batch.length; j < len; j++) {
        cmd = batch[j];
        [name, key, value, index] = cmd;
        if (key.match(this.namePrefixPat)) {
          key = key.replace(this.namePrefixPat, 'this/');
        }
        if (indexOf.call(setCmds, name) >= 0 && !this.varStorage.contains(key)) {
          this.varStorage.keys.push(key);
        }
        // track updates and respond to requests
        switch (name) {
          case 'error':
            console.log(`ERROR '${key}': value`);
            break;
          case 'request':
            this.verbose(`GOT REQUEST: ${JSON.stringify(cmd)}, batch: ${JSON.stringify(batch)}`);
            [x, name, num, dcmd] = cmd;
            this.handleDelegation(name, num, dcmd);
            break;
          default:
            this.varStorage.handle(cmd, (function(type, msg) {
              return console.log(`Error, '${type}': ${msg}`);
            }), function() {});
        }
      }
      if (numKeys !== this.varStorage.keys.length) {
        this.varStorage.keys.sort();
      }
      for (l = 0, len1 = batch.length; l < len1; l++) {
        cmd = batch[l];
        [name, key, value, index] = cmd;
        if (key.match(this.namePrefixPat)) {
          key = key.replace(this.namePrefixPat, 'this/');
        }
        if (name === 'set' && key === 'this/name') {
          this.name = value;
          this.namePrefixPat = new RegExp(`^peer/${value}/`);
        }
        if (indexOf.call(setCmds, name) >= 0) {
          ref = this.listenersFor(key);
          for (m = 0, len2 = ref.length; m < len2; m++) {
            block = ref[m];
            block(key, this.varStorage.values[key], cmd, batch);
          }
        } else if (name === 'value' && this.treeListeners[key]) {
          ref1 = this.treeListeners[key];
          for (o = 0, len3 = ref1.length; o < len3; o++) {
            cb = ref1[o];
            cb(cmd, batch);
          }
          delete this.treeListeners[key];
        }
      }
      return null;
    },
    listen: function(key, simulateSetsForTree, noChildren, callback) {
      key = key.replace(/^this\//, `peer/${this.name}/`);
      if (typeof simulateSetsForTree === 'function') {
        noChildren = simulateSetsForTree;
        simulateSetsForTree = false;
      }
      if (typeof noChildren === 'function') {
        callback = noChildren;
        noChildren = false;
      }
      if (noChildren) {
        callback = function(changedKey, value, oldValue, cmd, batch) {
          if (key === changedKey) {
            return callback(changedKey, value, oldValue, cmd, batch);
          }
        };
      }
      if (!callback) {
        [simulateSetsForTree, callback] = [null, simulateSetsForTree];
      }
      if (!this.changeListeners[key]) {
        this.changeListeners[key] = [];
        this.grabTree(key, (msg, batch) => {
          if (simulateSetsForTree) {
            this.sendTreeSets(this.setsForTree(msg), callback);
          } else {
            callback(key, (msg[4] === key ? msg[5] : null), null, msg, batch);
          }
          return this.changeListeners[key].push(callback);
        });
        return this.splice("this/listen", -1, 0, key);
      } else {
        return this.tree(key, simulateSetsForTree, callback);
      }
    }
  };

  //###

  // createDirectPeer xus, factory -- make a peer with an in-process connection to xus

  //###
  exports.createDirectPeer = function(xus, peerFactory) {
    var ctx, peer, peerConnection, xusConnection;
    ctx = {
      connected: true,
      server: xus
    };
    // the object that xus uses as its connection
    xusConnection = new DirectConnection();
    // the object that the peer uses as its connection
    peerConnection = new DirectConnection();
    peerConnection.verbose = xusConnection.verbose = xus.verbose;
    peer = (peerFactory != null ? peerFactory : function(con) {
      return new Peer(con);
    })(peerConnection);
    peerConnection.connect(xusConnection, xus, ctx);
    xusConnection.connect(peerConnection, peer, ctx);
    xus.addConnection(xusConnection);
    return peer;
  };

  DirectConnection = class DirectConnection {
    constructor() {
      this.q = [];
    }

    connect(otherConnection, otherMaster, ctx1) {
      this.otherConnection = otherConnection;
      this.otherMaster = otherMaster;
      this.ctx = ctx1;
    }

    isConnected() {
      return this.ctx.connected;
    }

    close() {
      this.ctx.connected = false;
      return this.q = this.otherConnection.q = null;
    }

    addCmd(cmd) {
      return this.q.push(cmd);
    }

    send() {
      var q;
      if (this.ctx.connected && this.q.length) {
        this.ctx.server.verbose(`${d(this)} SENDING ${this.name}, ${JSON.stringify(this.q)}`);
        [q, this.q] = [this.q, []];
        return this.otherMaster.processBatch(this.otherConnection, q);
      }
    }

    setMaster() {}

  };

  DelegationHandler = class DelegationHandler {
    constructor(peer1) {
      this.peer = peer1;
      this.values = {};
    }

    value(reqId, cmd) {}

    set(reqId, cmd) {}

    put(reqId, cmd) {}

    splice(reqId, cmd) {}

    removeFirst(reqId, cmd) {}

    removeAll(reqId, cmd) {}

    removeTree(reqId, cmd) {}

  };

}).call(this);

//# sourceMappingURL=peer.js.map
