// Generated by CoffeeScript 2.6.1
(function() {
  //###
  // Copyright (C) 2012, Bill Burdick
  // License: ZLIB license
  //###
  var CometClientConnection, CometConnection, Connection, ConnectionEndpoint, JSONCodec, ProxyMux, SocketConnection, WebSocketConnection, XusEndpoint, _, d, deadComets, error_bad_connection, exports;

  ({d} = exports = module.exports = require('./base'));

  ({error_bad_connection} = require('./proto'));

  _ = require('./lodash.min');

  //###
  // Codecs -- used by connections to encode and decode messages

  // codec must understand these messages:
  //   prepare connection -- initialize a connection to be used with the codec
  //   send connection, data -- encodes the data and calls connection.write(encodedData)
  //   newData connection, data -- handle new data on the connection

  //###

  //###
  // JSONCodec

  // encode/decode newline-terminated JSON batches

  //###
  exports.JSONCodec = JSONCodec = {
    prepare: function(con) {}, // con.saved = ''
    send: function(con, obj) {
      return con.write(`${JSON.stringify(obj)}\n`);
    },
    newData: function(con, data) {
      var batch, i, len, msgs, ref, results;
      if (typeof data !== 'string') {
        data = data.toString();
      }
      msgs = (con.saved + data).trim().split('\n');
      con.saved = data[data.length - 1] === '\n' ? '' : msgs.pop();
      ref = _.map(msgs, function(m) {
        var err;
        try {
          con.verbose(`PROCESSING BATCH: ${m}`);
          return JSON.parse(m);
        } catch (error) {
          err = error;
          con.addCmd(['error', `Could not parse message: ${m}`]);
          return con.send();
        }
      });
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        batch = ref[i];
        results.push(con.processBatch(batch));
      }
      return results;
    }
  };

  //###

  // CONNECTION CLASS

  // isConnected() -- returns whether the connection is connected
  // close() -- close the connection
  // addCmd cmd -- add a command to the queue
  // send() -- send the command queue

  // The default constructor takes a master and a codec

  // master must understand
  //   verbose
  //   addConnection(connection)
  //   disconnect(connection) -- which calls connection.basicClose()
  //   processBatch(connection, batch)

  // codec must be a codec

  // Connection classes must define these methods:
  //   write str -- send commands to the connection
  //   basicClose -- close connection

  //###
  exports.Connection = Connection = class Connection {
    write(str) {
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'write' method");
    }

    basicClose() {
      this.verbose(`CLOSING: ${this}`);
      return this.master.disconnect(this, error_bad_connection, "Connection has no 'disconnect' method");
    }

    constructor(master, codec, saved = '') {
      var err, ref;
      this.codec = codec;
      this.saved = saved;
      this.codec = (ref = this.codec) != null ? ref : JSONCodec;
      try {
        this.codec.prepare(this);
      } catch (error) {
        err = error;
        console.log(err.stack);
      }
      this.q = [];
      this.connected = true;
      this.setMaster(master);
    }

    setMaster(master1) {
      this.master = master1;
    }

    verbose(str) {
      return this.master.verbose(str);
    }

    isConnected() {
      return this.connected;
    }

    close() {
      this.connected = false;
      this.q = null;
      return this.basicClose();
    }

    addCmd(cmd) {
      return this.q.push(cmd);
    }

    send() {
      var q;
      if (this.connected && this.q.length) {
        this.verbose(`${this} SENDING ${JSON.stringify(this.q)}`);
        [q, this.q] = [this.q, []];
        return this.codec.send(this, q);
      }
    }

    newData(data) {
      this.verbose(`${this} read data: ${data}`);
      return this.codec.newData(this, data);
    }

    processBatch(batch) {
      return this.master.processBatch(this, batch);
    }

    toString() {
      var ref;
      return `${this.constructor.name} [${(ref = this.peerPath) != null ? ref : '??'}]`;
    }

  };

  exports.SocketConnection = SocketConnection = (function() {
    class SocketConnection extends Connection {
      constructor(master, con1, initialData) {
        super(master, null, (initialData != null ? initialData : '').toString());
        this.con = con1;
        this.con.on('data', (data) => {
          this.verbose(`${this} data: '${data}'`);
          return this.newData(data);
        });
        this.con.on('end', (hadError) => {
          this.verbose(`${this} disconnect`);
          return this.master.disconnect(this);
        });
        this.con.on('close', (hadError) => {
          this.verbose(`${this} disconnect`);
          return this.master.disconnect(this);
        });
        this.con.on('error', (hadError) => {
          this.verbose(`${this} disconnect`);
          return this.master.disconnect(this);
        });
        this.master.addConnection(this);
      }

      write(str) {
        return this.con.write(str);
      }

      basicClose() {
        var err;
        try {
          this.verbose(`CLOSING: ${this}`);
          return this.con.destroy();
        } catch (error) {
          err = error;
          return console.log(`Error closing connection: ${err.stack}`);
        }
      }

    };

    SocketConnection.prototype.connected = true;

    return SocketConnection;

  }).call(this);

  exports.WebSocketConnection = WebSocketConnection = (function() {
    class WebSocketConnection extends Connection {
      constructor(master, con1) {
        super(master);
        this.con = con1;
      }

      setMaster(master1) {
        this.master = master1;
        if (!this.pending) {
          this.pending = [];
        }
        if (this.master) {
          if (this.con.readyState === 1) {
            this.sendPending();
          } else {
            this.con.onopen = (evt) => {
              return this.sendPending();
            };
          }
          this.con.onmessage = (evt) => {
            console.log(`MESSAGE: ${JSON.stringify(evt.data)}`);
            return this.newData(evt.data);
          };
          this.con.onend = (hadError) => {
            return this.master.disconnect(this);
          };
          this.con.onclose = (hadError) => {
            return this.master.disconnect(this);
          };
          this.con.onerror = (hadError) => {
            return this.master.disconnect(this);
          };
          return this.master.addConnection(this);
        }
      }

      write(str) {
        return this.pending.push(str);
      }

      sendPending() {
        var i, len, msg, ref;
        console.log("CHANGING WRITE METHOD");
        this.write = function(str) {
          this.verbose(`${this} writing: ${str}`);
          return this.con.send(str);
        };
        ref = this.pending;
        for (i = 0, len = ref.length; i < len; i++) {
          msg = ref[i];
          this.write(msg);
        }
        this.pending = null;
        return this.sendPending = function() {};
      }

      basicClose() {
        var err;
        try {
          this.verbose(`CLOSING: ${this}`);
          return this.con.terminate();
        } catch (error) {
          err = error;
          return console.log(`Error closing connection: ${err.stack}`);
        }
      }

    };

    WebSocketConnection.prototype.connected = true;

    return WebSocketConnection;

  }).call(this);

  deadComets = {};

  exports.CometConnection = CometConnection = (function() {
    class CometConnection extends Connection {
      constructor(master, socket) {
        super(master);
        this.socket = socket;
      }

      setMaster(master1) {
        this.master = master1;
        console.log(`MASTER: ${this.master}`);
        this.master.addConnection(this);
        this.socket.on('disconnect', () => {
          return this.master.disconnect(this);
        });
        return this.socket.on('xusCmd', (data) => {
          this.verbose(`MESSAGE: ${data.str}`);
          return this.newData(data.str);
        });
      }

      write(str) {
        this.verbose(`${this} writing: ${str}`);
        return this.socket.emit('xusCmd', {
          str: str
        });
      }

      basicClose() {
        this.verbose(`CLOSING: ${this}`);
        if (!this.socket._zombi) {
          this.socket.emit('xusTerminate', '');
        }
        return deadComets[this.socket._uuid] = true;
      }

    };

    CometConnection.prototype.connected = true;

    return CometConnection;

  }).call(this);

  exports.CometClientConnection = CometClientConnection = (function() {
    class CometClientConnection extends Connection {
      constructor(master, url) {
        super(master);
        this.pending = [];
        this.socket = comet.connect(url).on('connect', () => {
          return this.sendPending();
        }).on('xusCmd', (data) => {
          this.verbose(`MESSAGE: ${data.str}`);
          return this.newData(data.str);
        }).on('xusTerminate', () => {
          return this.master.disconnect(this);
        });
      }

      write(str) {
        return this.pending.push(str);
      }

      sendPending() {
        var i, len, msg, ref;
        console.log("CHANGING WRITE METHOD");
        this.write = function(str) {
          this.verbose(`${this} writing: ${str}`);
          return this.socket.emit('xusCmd', {
            str: str
          });
        };
        ref = this.pending;
        for (i = 0, len = ref.length; i < len; i++) {
          msg = ref[i];
          this.write(msg);
        }
        return this.pending = null;
      }

      basicClose() {
        this.verbose(`CLOSING: ${this}`);
        if (!this.socket._zombi) {
          this.socket.emit('xus.terminate', '');
        }
        return deadComets[this.socket._uuid] = true;
      }

    };

    CometClientConnection.prototype.connected = true;

    return CometClientConnection;

  }).call(this);

  //####
  // Master for the muxed connection

  // forwards batches between muxed connection and endpoints

  // muxed connection -> processBatch -> endpoint
  // endpoint -> send(endpoint, batch) -> muxed connection

  //####
  exports.ProxyMux = ProxyMux = class ProxyMux {
    constructor(handler) {
      this.handler = handler;
      this.currentId = 0;
      this.connections = {};
    }

    verbose() {}

    prepare() {}

    addConnection(con) {
      this.verbose("proxy main connection");
      return this.mainConnection = con;
    }

    newConnectionEndpoint(conFactory) {
      return this.newConnection((id) => {
        var endPoint;
        endPoint = new ConnectionEndpoint(this, id);
        conFactory(endPoint);
        return endPoint;
      });
    }

    newPeer() {
      var peer;
      peer = new exports.Peer();
      console.log("SETTING CONNECTION");
      // peer.setConnection @newConnection (id)=> new XusEndpoint peer, @, id
      this.newConnection((id) => {
        peer.setConnection(new XusEndpoint(peer, this, id));
        return peer;
      });
      this.mainSend([['connect', peer.con.id]]);
      peer.con.newconnection = false;
      return peer;
    }

    newConnection(factory) {
      var con, id;
      id = this.currentId++;
      con = factory(id);
      this.verbose(`proxy got new connection: ${d(con)}, id: ${id}`);
      this.connections[id] = con;
      return con;
    }

    processBatch(muxedCon, batch) { // called by endpoint; calls @handleDemuxedBatch
      var b, cmd, con, id;
      this.verbose(`proxy demuxing batch: ${JSON.stringify(batch)}`);
      [cmd, id] = batch[0];
      con = this.connections[id];
      switch (cmd) {
        case 'connect':
          this.verbose("MUX connect");
          con = new XusEndpoint(this.handler, this, id);
          this.connections[id] = con;
          this.handler.addConnection(con);
          break;
        case 'disconnect':
          this.verbose("MUX disconnect");
          if (con) {
            this.removeConnection(con);
            con.disconnect();
          }
          break;
        case 'data':
          this.verbose(`MUX data: ${JSON.stringify(batch.slice(1))}`);
      }
      b = batch.slice(1);
      if (b.length) {
        return this.handler.processBatch(con, b);
      }
    }

    disconnect(con) {
      if (con === this.mainConnection) {
        return this.mainDisconnect(con);
      } else {
        this.mainSend([['disconnect', con.id]]);
        return this.removeConnection(con);
      }
    }

    mainDisconnect(con) {
      console.log("Disconnecting mux connection");
      return process.exit();
    }

    removeConnection(con) {
      var connected;
      if (connected) {
        connected = false;
        return delete this.connections[con.id];
      }
    }

    mux(endpoint, batch) {
      var b;
      b = batch.slice(0);
      b.splice(0, 0, ['data', endpoint.id]);
      endpoint.newConnection = false;
      return this.mainSend(b);
    }

    mainSend(batch) {
      this.verbose(`${this} proxy forwarding muxed batch: ${JSON.stringify(batch)} to ${this.mainConnection.constructor.name}`);
      this.mainConnection.q = batch;
      return this.mainConnection.send();
    }

    prepare(con) {}

  };

  //####
  // Socket <-> mux; acts as a connection master

  // mux -> forward -> socket
  // mux <- processBatch <- socket
  //####
  ConnectionEndpoint = class ConnectionEndpoint { // connected to an endpoint
    constructor(mux, id1) {
      this.mux = mux;
      this.id = id1;
      this.verbose("New ConnectionEndpoint");
      this.newConnection = true;
    }

    verbose(str) {
      return this.mux.verbose(str);
    }

    addConnection(con1) {
      this.con = con1;
      this.verbose(`ConnectionEndpoint connection: ${this.con.constructor.name}`);
      this.mux.mainSend([['connect', this.id]]);
      return this.newconnection = false;
    }

    disconnect(con) {
      this.verbose("ConnectionEndpoint disconnecting");
      return this.mux.disconnect(this);
    }

    send(demuxedBatch) {
      this.verbose(`ConnectionEndpoint writing: ${JSON.stringify(demuxedBatch)}`);
      this.con.q = demuxedBatch;
      return this.con.send();
    }

    processBatch(con, batch) {
      this.verbose(`Socket endpoint read: ${batch}`);
      return this.mux.mux(this, batch);
    }

  };

  XusEndpoint = (function() {
    //####
    // Xus <-> mux; acts as a connection to xus

    // treats mux as a codec

    // Xus -> addCmd, send -> proxy
    // proxy -> processBatch -> Xus
    //####
    class XusEndpoint extends Connection { // connected to an endpoint
      constructor(master, proxy, id1) {
        super(master, proxy);
        this.id = id1;
        this.proxy = proxy;
        this.verbose = this.proxy.verbose;
      }

      basicClose() {
        this.verbose(`CLOSING: ${this}`);
        return this.proxy.disconnect(this);
      }

      send() {
        var q;
        this.verbose(`SEND ${JSON.stringify(this.q)}`);
        [q, this.q] = [this.q, []];
        return this.proxy.mux(this, q);
      }

      disconnect() {
        return this.master.disconnect(this);
      }

    };

    XusEndpoint.prototype.newConnection = false;

    return XusEndpoint;

  }).call(this);

}).call(this);

//# sourceMappingURL=transport.js.map
